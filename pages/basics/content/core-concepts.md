---
title: Core Concepts
---

### glamorous

The `glamorous` function is the default export. It allows you to create
glamorous components that render the styles to the component you give it. This
is done by forwarding a `className` prop to the component you tell it to render.
But before we get into how you wrap custom components, let's talk about the
built-in DOM components.

#### built-in DOM component factories

For every DOM element, there is an associated `glamorous` component factory
attached to the `glamorous` function. As above, you can access these factories
like so: `glamorous.div`, `glamorous.a`, `glamorous.article`, etc.

```js
const MyStyledSection = glamorous.section({ margin: 1 })

<MyStyledSection>content</MyStyledSection>
// rendered output: <section class="<glamor-generated-class>">content</section>
// styles applied: {margin: 1}
```

#### GlamorousComponent

The `GlamorousComponent` is what is returned from the [glamorousComponentFactory](/api#glamorousComponentFactory).
Its job is to get all the styles together, get a `className` (from [`glamor`](https://github.com/threepointone/glamor))
and forward that on to your component.

#### built-in GlamorousComponents

Often you want to style something without actually giving it a name (because
naming things is hard). So glamorous also exposes a pre-created
`GlamorousComponent` for each DOM node type which makes this reasonable to do:

```js
const { Div, Span, A, Img } = glamorous

function MyUserInterface({name, tagline, imageUrl, homepage, size}) {
  const nameSize = size
  const taglineSize = size * 0.5
  return (
    <Div display="flex" flexDirection="column" justifyContent="center">
      <A href={homepage} textDecoration="underline" color="#336479">
        <Img borderRadius="50%" height={180} src={imageUrl} />
        <Div fontSize={nameSize} fontWeight="bold">{name}</Div>
      </A>
      <Span fontSize={taglineSize} color="#767676">
        {tagline}
      </Span>
    </Div>
  )
}
```

> Try this out in your browser [here](https://codesandbox.io/s/wmRo8OKDm)!

Having to name all of that stuff could be tedious, so having these pre-built
components is handy. The other handy bit here is that the props _are_ the styles
for these components. Notice that glamorous can distinguish between props that
are for styling and those that are have semantic meaning (like with the `Img`
and `A` components which make use of `src` and `href` props).

The `css` prop can be used to provide styles as an object.

```js
import glamorous, {withTheme} from 'glamorous'
const { Div, Span } = glamorous

const predefinedStyle = {
  color: '#767676',
  fontSize: 18,
}

const MyUserInterface = withTheme(function ({tagline, theme}) {
  return (
    <Div
      css={{
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'center',
        [theme.mq.tablet]: {
          flexDirection: 'row'
        }
      }}
     >
      <Span css={predefinedStyle}>
        {tagline}
      </Span>
    </Div>
  )
})
```

One other tip... This totally works:

```js
<glamorous.Div color="blue">
  JSX is pretty wild!
</glamorous.Div>
```

#### Overriding component styles

The most common scenario for using props is to override the style of an
existing component (generated by `glamorous` or not). That can be achieved
by using the props `className`, `css` and `theme` or simply component
composition with the `glamorous()` function.

If you're interested in knowing more about using the `theme` prop, see the
[Theming](/advanced#Theming) section instead for a more detailed explanation. In this
section we'll explain how to use `className`, `css` and composition to override
the styles of a component.

Let's see how that can be done in the examples below.

> Try this out in your browser [here](https://codesandbox.io/s/Kro5369wG)!

We'll use this as our `GlamorousComponent`:

```javascript
const MyStyledDiv = glamorous.div({margin: 1, fontSize: 1, padding: 1})
```
##### using `className`

For each `className` you provide, the `GlamorousComponent` will check to see
whether it is a [`glamor`][glamor] generated `className` (can be from raw glamor
or from `glamorous`, doesn't matter). If it is, it will get the original styles
that were used to generate that `className` and merge those with the styles for
the element that's rendered in a way that the provided `className`'s styles win
in the event of a conflict.

If the `className` is not generated by `glamor`, then it will simply be
forwarded along with the `GlamorousComponent`-generated `className`.

```js
const myCustomGlamorStyles = glamor.css({fontSize: 2})
<MyStyledDiv className={`${myCustomGlamorStyles} custom-class`} />
// styles applied:
// {margin: 1, fontSize: 2, padding: 1}
// as well as any styles custom-class applies
```

##### using `css`

This can be the same type as any of the styles provided
(as in `glamorous.div(...styles)`). If specified, it will be merged with this
component's styles and take highest priority over the component's predefined
styles.

```js
const myCustomGlamorStyles = glamor.css({fontSize: 2, padding: 2})
<MyStyledDiv
  className={`${myCustomGlamorStyles} custom-class`}
  css={{padding: 3}}
/>
// styles applied:
// {margin: 1, fontSize: 2, padding: 3}
// as well as any styles custom-class applies
```

##### using `glamorous()` composition

If we just want to extend the styles of an existing component it can be done
by using the `glamorous()` function.

```js
const MyComposedStyledDiv = glamorous(MyStyledDiv)({fontSize: 4, padding: 4})
<MyComposedStyledDiv />
// styles applied:
// {margin: 1, fontSize: 4, padding: 4}
```

In fact, the built-in DOM component factories provided are just an abstraction
of this function, so `glamorous.div` could be written as `glamorous('div')` instead.
